#include <iostream>using namespace std;class Solution {public:    // my basic idea: 2 can be implemented by right shift or just multiplication    // x ^ 2n = (x^2)^n; so use recursion    // do I need to consider negative        double myPow2(double x, long long n) {        if ( n < 0 )  return 1.0/myPow2(x, -1*n);         if ( n == 0 ) return 1.0;         if ( x == 0 ) return 0;        if ( x == 1.0) return 1.0;         if ( n & 0x1) return ( myPow2(x, n - 1) * x ) ;         else {            double y = myPow2( x, n/2);             return y*y;         }            }        double myPow(double x, int n) {        return myPow2(x, n);             }};int main(void){    long long n;    double x;     Solution sol;         x = 1.0;    n = -2147483648LL;        cout << x << "," << n << "," << sol.myPow2( x, n ) << endl;      x = 8.88023;    n = 3 ;    cout << x << "," << n << "," << sol.myPow2( x, n ) << endl;     }